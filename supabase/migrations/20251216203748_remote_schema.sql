drop extension if exists "pg_net";

drop trigger if exists "organizations_audit" on "public"."organizations";

drop trigger if exists "organizations_updated_at" on "public"."organizations";

drop trigger if exists "zone_records_increment_soa_delete" on "public"."zone_records";

drop trigger if exists "zone_records_increment_soa_insert" on "public"."zone_records";

drop trigger if exists "zone_records_increment_soa_update" on "public"."zone_records";

drop policy "Authenticated users can create organization memberships" on "public"."organization_members";

drop policy "Authenticated users can create organizations" on "public"."organizations";

drop policy "Users can view their organizations" on "public"."organizations";

drop function if exists "public"."increment_zone_soa_serial"();

drop index if exists "public"."idx_orgs_deleted_at";

drop index if exists "public"."organizations_owner_id_idx";


  create table "public"."irongrove_contact_submissions" (
    "id" uuid not null default gen_random_uuid(),
    "created_at" timestamp with time zone not null default timezone('utc'::text, now()),
    "name" text not null,
    "email" text not null,
    "phone" text not null,
    "subject" text not null,
    "message" text not null,
    "status" text not null default 'new'::text,
    "notes" text,
    "updated_at" timestamp with time zone default timezone('utc'::text, now())
      );


alter table "public"."irongrove_contact_submissions" enable row level security;


  create table "public"."marketing-website-contact-form" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "name" text not null,
    "email" text not null,
    "phone_number" text not null,
    "message" text not null,
    "ip_address" inet,
    "user_agent" text,
    "content_hash" bytea generated always as (extensions.digest(((lower(email) || '|'::text) || "left"(message, 2000)), 'sha256'::text)) stored,
    "inquiry_type" text
      );


alter table "public"."marketing-website-contact-form" enable row level security;

CREATE INDEX audit_logs_actor_type_idx ON public.audit_logs USING btree (actor_type);

CREATE INDEX audit_logs_admin_created_idx ON public.audit_logs USING btree (actor_type, created_at DESC) WHERE (actor_type = 'admin'::text);

CREATE INDEX audit_logs_admin_user_idx ON public.audit_logs USING btree (admin_user_id);

CREATE INDEX idx_contact_created_at ON public."marketing-website-contact-form" USING btree (created_at DESC);

CREATE INDEX idx_contact_email ON public."marketing-website-contact-form" USING btree (email);

CREATE INDEX idx_contact_inquiry_type ON public."marketing-website-contact-form" USING btree (inquiry_type);

CREATE INDEX irongrove_contact_submissions_created_at_idx ON public.irongrove_contact_submissions USING btree (created_at DESC);

CREATE UNIQUE INDEX irongrove_contact_submissions_pkey ON public.irongrove_contact_submissions USING btree (id);

CREATE INDEX irongrove_contact_submissions_status_idx ON public.irongrove_contact_submissions USING btree (status);

CREATE UNIQUE INDEX "marketing-website-contact-form_pkey" ON public."marketing-website-contact-form" USING btree (id);

CREATE INDEX organizations_deleted_at_idx ON public.organizations USING btree (deleted_at);

CREATE INDEX organizations_status_idx ON public.organizations USING btree (status);

CREATE INDEX profiles_status_idx ON public.profiles USING btree (status);

CREATE UNIQUE INDEX uniq_contact_content_hash ON public."marketing-website-contact-form" USING btree (content_hash);

CREATE INDEX zones_deleted_at_idx ON public.zones USING btree (deleted_at);

CREATE INDEX zones_live_idx ON public.zones USING btree (live);

alter table "public"."irongrove_contact_submissions" add constraint "irongrove_contact_submissions_pkey" PRIMARY KEY using index "irongrove_contact_submissions_pkey";

alter table "public"."marketing-website-contact-form" add constraint "marketing-website-contact-form_pkey" PRIMARY KEY using index "marketing-website-contact-form_pkey";

alter table "public"."marketing-website-contact-form" add constraint "email_format_check" CHECK ((email ~* '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$'::text)) not valid;

alter table "public"."marketing-website-contact-form" validate constraint "email_format_check";

alter table "public"."marketing-website-contact-form" add constraint "marketing-website-contact-form_inquiry_type_check" CHECK ((length(inquiry_type) <= 50)) not valid;

alter table "public"."marketing-website-contact-form" validate constraint "marketing-website-contact-form_inquiry_type_check";

alter table "public"."marketing-website-contact-form" add constraint "message_length_check" CHECK ((length(message) <= 2000)) not valid;

alter table "public"."marketing-website-contact-form" validate constraint "message_length_check";

alter table "public"."marketing-website-contact-form" add constraint "name_length_check" CHECK ((length(name) <= 120)) not valid;

alter table "public"."marketing-website-contact-form" validate constraint "name_length_check";

alter table "public"."marketing-website-contact-form" add constraint "phone_length_check" CHECK (((phone_number IS NULL) OR (length(phone_number) <= 30))) not valid;

alter table "public"."marketing-website-contact-form" validate constraint "phone_length_check";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.check_expired_invitations()
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
begin
  update public.organization_invitations
  set status = 'expired'
  where status = 'pending' 
    and expires_at < now();
end;
$function$
;

CREATE OR REPLACE FUNCTION public.check_zone_name_exists(zone_name text)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
begin
  return exists(
    select 1 from public.zones
    where name = zone_name
      and deleted_at is null
  );
end;
$function$
;

CREATE OR REPLACE FUNCTION public.increment_zone_serial_on_record_change()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  target_zone_id uuid;
BEGIN
  target_zone_id := COALESCE(NEW.zone_id, OLD.zone_id);
  UPDATE public.zones SET soa_serial = soa_serial + 1, updated_at = now() WHERE id = target_zone_id;
  RETURN COALESCE(NEW, OLD);
END;
$function$
;

CREATE OR REPLACE FUNCTION public.restore_organization(org_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
begin
  update public.organizations
  set 
    status = 'active',
    deleted_at = null,
    updated_at = now()
  where id = org_id;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.restore_zone(zone_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
begin
  update public.zones
  set deleted_at = null,
      updated_at = now()
  where id = zone_id;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.soft_delete_organization(org_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
begin
  update public.organizations
  set 
    status = 'deleted',
    deleted_at = now(),
    updated_at = now()
  where id = org_id;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.soft_delete_zone(zone_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
begin
  update public.zones
  set deleted_at = now(),
      updated_at = now()
  where id = zone_id;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.update_last_activity(session_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
begin
  update public.activity_sessions
  set last_activity_at = now()
  where id = session_id
    and user_id = auth.uid();
end;
$function$
;

CREATE OR REPLACE FUNCTION public.verify_api_token(token_hash_param text)
 RETURNS TABLE(token_id uuid, user_id uuid, organization_id uuid, scopes text[], expires_at timestamp with time zone)
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
begin
  -- Update last_used_at for the token
  update public.api_tokens
  set last_used_at = now()
  where token_hash = token_hash_param
    and active = true
    and (expires_at is null or expires_at > now());
  
  -- Return token details
  return query
  select 
    t.id,
    t.user_id,
    t.organization_id,
    t.scopes,
    t.expires_at
  from public.api_tokens t
  where t.token_hash = token_hash_param
    and t.active = true
    and (t.expires_at is null or t.expires_at > now());
end;
$function$
;

CREATE OR REPLACE FUNCTION public.update_member_last_accessed(p_organization_id uuid, p_user_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
begin
  update public.organization_members
  set last_accessed_at = now()
  where organization_id = p_organization_id
    and user_id = p_user_id;
end;
$function$
;

grant delete on table "public"."irongrove_contact_submissions" to "anon";

grant insert on table "public"."irongrove_contact_submissions" to "anon";

grant references on table "public"."irongrove_contact_submissions" to "anon";

grant select on table "public"."irongrove_contact_submissions" to "anon";

grant trigger on table "public"."irongrove_contact_submissions" to "anon";

grant truncate on table "public"."irongrove_contact_submissions" to "anon";

grant update on table "public"."irongrove_contact_submissions" to "anon";

grant delete on table "public"."irongrove_contact_submissions" to "authenticated";

grant insert on table "public"."irongrove_contact_submissions" to "authenticated";

grant references on table "public"."irongrove_contact_submissions" to "authenticated";

grant select on table "public"."irongrove_contact_submissions" to "authenticated";

grant trigger on table "public"."irongrove_contact_submissions" to "authenticated";

grant truncate on table "public"."irongrove_contact_submissions" to "authenticated";

grant update on table "public"."irongrove_contact_submissions" to "authenticated";

grant delete on table "public"."irongrove_contact_submissions" to "service_role";

grant insert on table "public"."irongrove_contact_submissions" to "service_role";

grant references on table "public"."irongrove_contact_submissions" to "service_role";

grant select on table "public"."irongrove_contact_submissions" to "service_role";

grant trigger on table "public"."irongrove_contact_submissions" to "service_role";

grant truncate on table "public"."irongrove_contact_submissions" to "service_role";

grant update on table "public"."irongrove_contact_submissions" to "service_role";

grant delete on table "public"."marketing-website-contact-form" to "anon";

grant insert on table "public"."marketing-website-contact-form" to "anon";

grant references on table "public"."marketing-website-contact-form" to "anon";

grant select on table "public"."marketing-website-contact-form" to "anon";

grant trigger on table "public"."marketing-website-contact-form" to "anon";

grant truncate on table "public"."marketing-website-contact-form" to "anon";

grant update on table "public"."marketing-website-contact-form" to "anon";

grant delete on table "public"."marketing-website-contact-form" to "authenticated";

grant insert on table "public"."marketing-website-contact-form" to "authenticated";

grant references on table "public"."marketing-website-contact-form" to "authenticated";

grant select on table "public"."marketing-website-contact-form" to "authenticated";

grant trigger on table "public"."marketing-website-contact-form" to "authenticated";

grant truncate on table "public"."marketing-website-contact-form" to "authenticated";

grant update on table "public"."marketing-website-contact-form" to "authenticated";

grant delete on table "public"."marketing-website-contact-form" to "service_role";

grant insert on table "public"."marketing-website-contact-form" to "service_role";

grant references on table "public"."marketing-website-contact-form" to "service_role";

grant select on table "public"."marketing-website-contact-form" to "service_role";

grant trigger on table "public"."marketing-website-contact-form" to "service_role";

grant truncate on table "public"."marketing-website-contact-form" to "service_role";

grant update on table "public"."marketing-website-contact-form" to "service_role";


  create policy "auth_delete"
  on "public"."irongrove_contact_submissions"
  as permissive
  for delete
  to authenticated
using (true);



  create policy "auth_select"
  on "public"."irongrove_contact_submissions"
  as permissive
  for select
  to authenticated
using (true);



  create policy "auth_update"
  on "public"."irongrove_contact_submissions"
  as permissive
  for update
  to authenticated
using (true);



  create policy "public_insert"
  on "public"."irongrove_contact_submissions"
  as permissive
  for insert
  to public
with check (true);



  create policy "Allow anonymous inserts via API"
  on "public"."marketing-website-contact-form"
  as permissive
  for insert
  to anon
with check (true);



  create policy "Allow authenticated reads"
  on "public"."marketing-website-contact-form"
  as permissive
  for select
  to authenticated
using (true);



  create policy "Allow service role inserts"
  on "public"."marketing-website-contact-form"
  as permissive
  for insert
  to service_role
with check (true);



  create policy "allow_select_own_memberships"
  on "public"."organization_members"
  as permissive
  for select
  to public
using ((user_id = auth.uid()));



  create policy "organization_members_insert_policy"
  on "public"."organization_members"
  as permissive
  for insert
  to authenticated
with check (true);



  create policy "organizations_insert_policy"
  on "public"."organizations"
  as permissive
  for insert
  to authenticated
with check (true);



  create policy "users_can_select_their_organizations"
  on "public"."organizations"
  as permissive
  for select
  to public
using (((owner_id = auth.uid()) OR (EXISTS ( SELECT 1
   FROM public.organization_members
  WHERE ((organization_members.organization_id = organizations.id) AND (organization_members.user_id = auth.uid()))))));


CREATE TRIGGER zone_records_increment_serial_delete AFTER DELETE ON public.zone_records FOR EACH ROW EXECUTE FUNCTION public.increment_zone_serial_on_record_change();

CREATE TRIGGER zone_records_increment_serial_insert AFTER INSERT ON public.zone_records FOR EACH ROW EXECUTE FUNCTION public.increment_zone_serial_on_record_change();

CREATE TRIGGER zone_records_increment_serial_update AFTER UPDATE ON public.zone_records FOR EACH ROW EXECUTE FUNCTION public.increment_zone_serial_on_record_change();

CREATE TRIGGER zones_increment_serial_on_update BEFORE UPDATE ON public.zones FOR EACH ROW EXECUTE FUNCTION public.increment_zone_serial_on_zone_change();


  create policy "Allow authenticated users to upload avatars"
  on "storage"."objects"
  as permissive
  for insert
  to authenticated
with check ((bucket_id = 'avatars'::text));



  create policy "Allow public to view avatars"
  on "storage"."objects"
  as permissive
  for select
  to public
using ((bucket_id = 'avatars'::text));



  create policy "Allow users to update own avatars"
  on "storage"."objects"
  as permissive
  for update
  to authenticated
using (((bucket_id = 'avatars'::text) AND ((auth.uid())::text = (storage.foldername(name))[1])));



  create policy "avatar_delete_own_folder"
  on "storage"."objects"
  as permissive
  for delete
  to authenticated
using (((bucket_id = 'avatars'::text) AND (POSITION((((auth.uid())::text || '/'::text)) IN (name)) = 1)));



  create policy "avatar_insert_own_folder"
  on "storage"."objects"
  as permissive
  for insert
  to authenticated
with check (((bucket_id = 'avatars'::text) AND (POSITION((((auth.uid())::text || '/'::text)) IN (name)) = 1)));



  create policy "avatar_list_own_folder"
  on "storage"."objects"
  as permissive
  for select
  to authenticated
using (((bucket_id = 'avatars'::text) AND (POSITION((((auth.uid())::text || '/'::text)) IN (name)) = 1)));



  create policy "avatar_update_own_folder"
  on "storage"."objects"
  as permissive
  for update
  to authenticated
using (((bucket_id = 'avatars'::text) AND (POSITION((((auth.uid())::text || '/'::text)) IN (name)) = 1)))
with check (((bucket_id = 'avatars'::text) AND (POSITION((((auth.uid())::text || '/'::text)) IN (name)) = 1)));



